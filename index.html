<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake Game</title>
<style>
  body {
    margin: 0; background: #071321; color: #7efc6d; font-family: monospace, monospace;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    height: 100vh;
    position: relative;
  }
  canvas {
    background: #0f1724; border-radius: 10px; display: block;
    touch-action: none; /* Bloqueia scroll no mobile */
  }
  #score {
    margin: 10px; font-size: 1.2rem; font-weight: bold;
  }
  .game-over-overlay {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.7);
    display: flex; justify-content: center; align-items: center;
    color: white; font-size: 2rem; cursor: pointer;
    user-select: none;
    z-index: 10;
    font-family: Arial, sans-serif;
    text-align: center;
    padding: 0 20px;
  }
  footer {
    position: fixed;
    bottom: 5px;
    width: 100%;
    text-align: center;
    color: #4ade80;
    font-family: Arial, sans-serif;
    font-size: 14px;
    user-select: none;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="score"></div>
<canvas id="game" width="400" height="400"></canvas>
<div id="gameOver" class="game-over-overlay" style="display:none;"></div>

<footer></footer>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const gameOverEl = document.getElementById('gameOver');
  const footerEl = document.querySelector('footer');

  // Detecta idioma principal do navegador: pt ou en (default en)
  const lang = navigator.language.startsWith('pt') ? 'pt' : 'en';

  // Textos em PT e EN
  const texts = {
    pt: {
      score: 'Pontuação: ',
      gameOver: 'Game Over! Clique para reiniciar',
      madeBy: 'Feito por: TheuXs',
      pauseHint: 'Espaço: Pausar',
    },
    en: {
      score: 'Score: ',
      gameOver: 'Game Over! Click to restart',
      madeBy: 'Made by: TheuXs',
      pauseHint: 'Space: Pause',
    }
  };

  const t = texts[lang];

  const gridSize = 20;
  const tile = canvas.width / gridSize;

  let snake, direction, nextDirection, food, score;
  let running, paused;

  let lastTime = 0;
  const speed = 10;
  const stepInterval = 1000 / speed;

  function restart() {
    snake = [{ x: 10, y: 10 }];
    direction = { x: 0, y: 0 };
    nextDirection = { x: 0, y: 0 };
    food = placeFood();
    score = 0;
    running = true;
    paused = false;
    lastTime = 0;
    updateScore();
    gameOverEl.style.display = 'none';
  }

  function placeFood() {
    let pos;
    do {
      pos = {
        x: Math.floor(Math.random() * gridSize),
        y: Math.floor(Math.random() * gridSize),
      };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    return pos;
  }

  function updateScore() {
    scoreEl.textContent = t.score + score + (paused ? ' — ' + t.pauseHint : '');
  }

  function update() {
    if (!running || paused) return;

    if (nextDirection.x !== -direction.x || nextDirection.y !== -direction.y) {
      direction = nextDirection;
    }

    if (direction.x === 0 && direction.y === 0) {
      return; // sem movimento ainda
    }

    const newHead = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    // Teleporte bordas
    if (newHead.x < 0) newHead.x = gridSize - 1;
    else if (newHead.x >= gridSize) newHead.x = 0;

    if (newHead.y < 0) newHead.y = gridSize - 1;
    else if (newHead.y >= gridSize) newHead.y = 0;

    if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
      running = false;
      gameOverEl.textContent = t.gameOver;
      gameOverEl.style.display = 'flex';
      return;
    }

    snake.unshift(newHead);

    if (newHead.x === food.x && newHead.y === food.y) {
      score++;
      updateScore();
      food = placeFood();
    } else {
      snake.pop();
    }
  }

  function draw() {
    ctx.fillStyle = '#071321';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(food.x * tile, food.y * tile, tile, tile);

    ctx.fillStyle = '#7efc6d';
    snake.forEach(s => {
      ctx.fillRect(s.x * tile, s.y * tile, tile, tile);
    });
  }

  function gameLoop(time = 0) {
    if (!lastTime) lastTime = time;
    const delta = time - lastTime;
    if (delta > stepInterval) {
      update();
      draw();
      lastTime = time;
    }
    if (running) {
      requestAnimationFrame(gameLoop);
    }
  }

  window.addEventListener('keydown', e => {
    if (!running && e.code === 'Space') {
      restart();
      requestAnimationFrame(gameLoop);
      return;
    }
    if (!running) return;

    switch (e.code) {
      case 'ArrowUp': case 'KeyW': nextDirection = { x: 0, y: -1 }; break;
      case 'ArrowDown': case 'KeyS': nextDirection = { x: 0, y: 1 }; break;
      case 'ArrowLeft': case 'KeyA': nextDirection = { x: -1, y: 0 }; break;
      case 'ArrowRight': case 'KeyD': nextDirection = { x: 1, y: 0 }; break;
      case 'Space': paused = !paused; updateScore(); break;
    }
  });

  gameOverEl.addEventListener('click', () => {
    restart();
    requestAnimationFrame(gameLoop);
  });

  let touchStart = null;
  canvas.addEventListener('touchstart', e => {
    if (!running) return;
    const t = e.touches[0];
    touchStart = { x: t.clientX, y: t.clientY };
  }, { passive: true });

  canvas.addEventListener('touchend', e => {
    if (!running || !touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 20) nextDirection = { x: 1, y: 0 };
      else if (dx < -20) nextDirection = { x: -1, y: 0 };
    } else {
      if (dy > 20) nextDirection = { x: 0, y: 1 };
      else if (dy < -20) nextDirection = { x: 0, y: -1 };
    }
    touchStart = null;
  }, { passive: true });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
  }, { passive: false });

  footerEl.textContent = t.madeBy;

  restart();
  requestAnimationFrame(gameLoop);
})();
</script>

</body>
</html>